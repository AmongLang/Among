among: BR*
       ( "macro" BR* macroDefinition BR
       | ( "operator" | "keyword" ) BR* operatorDefinition BR
       | "undef" BR* undef BR+
       | nameable BR*
       | complexPrimitive BR* )* EOF

macroDefinition: word BR*
                 ( "{" BR* macroParam? BR* "}" BR*
                 | "(" BR* macroParam? BR* ")" BR*
                 | "[" BR* macroParam? BR* "]" BR* )?
                 ":" BR* expr
macroParam: paramName (BR* "=" BR* expr)? ( BR* "," BR* defParam? )?

operatorDefinition: word BR* "as" BR*
                    ( "binary" | "prefix" | "postfix" )
                    ( ":" BR* value )?  # Parsed as decimal value

undef: "macro" BR* name
       ( "{" BR* "}"
       | "[" BR* "]"
       | "(" BR* ")" )?
     | ( "operator" | "keyword" ) BR* name

expr: nameable | complexPrimitive | value

nameable: name?
          ( "{" BR* obj? BR* "}"
          | "[" BR* list? BR* "]"
          | "(" BR* oper? BR* ")" )

obj: key BR* ":" expr (  ( BR+ | BR* "," BR* ) obj? )?
list: expr ( ( BR+ | BR* "," BR* ) list? )?
oper: operExpr ( BR* "," BR* operExpr? )?

# OPERATORS

operExpr: primary # defined by script

primary: nameable | name

# LEXER

word: regex; [^\s:,{}\[\]()]+  # used in plain keywords, such as 'macro' 'as' 'operator' and such
name: simpleName | complexPrimitive
key: simpleKey | complexPrimitive
paramName: regex; ^[\s:,{}\[\]()=]+  # kek

simpleName: regex; [^\s,{}\[\]()]+
simpleKey: regex; [^:,{}\r\n]+
complexPrimitive: ""\"" ( BR ( "\s"* "|" )? | ^( BR | "\"" ) )* "\""
                | "'" ( BR ( "\s"* "|" )? | ^( BR | "'" ) )* "'"
value: regex; ^[^"'][^,{}\[\]()\r\n]*
number: regex; [+-]?[0-9]+(\.[0-9]+)?

BR: regex; \r \n? | \n